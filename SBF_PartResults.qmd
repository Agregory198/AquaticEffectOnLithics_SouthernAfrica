---
title: "Steenbokfontein Preliminary Results"
bibliography: references.bib
link-citations: true
execute: 
  echo: false
  warning: false
  message: false
format: html
editor: visual
---

```{r library}
#| warning: false
#| message: false


# To plot figures
library(ggplot2)
library(forcats)
library(ggpubr)
library(ggridges)
library(cowplot)

library(infer)

library(viridis)

library(scales)
library(stringr)

# To generate tables
library(gtsummary)
library(gt)
library(broom)
library(broom.mixed)

library(stargazer)
library(kableExtra)

# To tidy the data
library(tidyr)
library(dplyr)
library(forcats)
library(tidybayes)

# Bayesian models
library(brms)
library(emmeans)
```

```{r ScraperRetouchFormula}
# Calculate scraper retouch intensity
scraper_red <- function(L, D, a, b){
  
  t = D * sin(a)
  D3 = D * cos(a)
  D1 = t/(sin(b))
  D4 = (t * cos(b))/(sin(b))
  
  D2 = D4 - D3
  
  B = t * (sin(b)) # define base B to find height (which is also D1)
  
  h = sin(b) * ((t*(cos(b)/sin(b))) - (D*cos(a)))
  
  A =  0.5 * B * h# find values of area now
  
  RE = L*((D^2)/2)*((sin(a*(pi/180))^2 * 
                       (cos(b*(pi/180))/sin(b*(pi/180)))) - 
                      (sin(a*(pi/180)) * cos(a*(pi/180))))
  
  
  output <- tibble(Reduction = RE)
  
  return(output)
  
  
}
```

```{r ReadData}
# Read and clean data
df <- read.csv("AG_Summer2024_06_26_Final.csv") |>
  filter(RAWMATERIAL != "BWA UPPER 1" &
           RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  mutate(STRAT = ifelse(STRAT == "3a", "3", # combine strat 3a and 3b
                        ifelse(STRAT == "3b", "3", STRAT)),
         STRAT_mod = ifelse(STRAT %in% c("4a", "4b"), "Terrestrial", "Coastal")) |>
  mutate(STRAT = factor(STRAT),
         STRAT_mod = factor(STRAT_mod),
         RAWMATERIAL = factor(RAWMATERIAL))

# take average core flake scar length
df |>
  dplyr::filter(ARTIFACTCLASS=="Core") |>
  group_by(RAWMATERIAL)|>
  dplyr::summarise(a = mean(LENGHTLONGESTFLAKESCAR)) -> df.core_average

# Subset data by flakes and flake variables
df.flakes <- df |>
  filter(ARTIFACTCLASS == "Flake" & COMPLETENESS == "Complete") |>
  select(1:11,33:35,38,48:53,64:69,STRAT_mod)|>
  mutate(TECHLENGTH = as.numeric(TECHLENGTH),
         Utility = MAXWIDTH*MAXLENGTH,
         Reduction = ifelse(
           RAWMATERIAL == "Opaline/CCS", 
          TECHLENGTH/df.core_average$a[which(df.core_average == "Opaline/CCS")],
                      ifelse(RAWMATERIAL == "Quartz", 
          TECHLENGTH/df.core_average$a[which(df.core_average == "Quartz")],
                       ifelse(RAWMATERIAL == "Quartzite", 
          TECHLENGTH/df.core_average$a[which(df.core_average == "Quartzite")],
                              TECHLENGTH/17.70))))

# Subset data by cores and core variables
df.cores <- df |>
  filter(ARTIFACTCLASS == "Core" & CORECOMPLETENESS == "Complete") |>
  select(1:10,13,54:69) |>
  mutate(SA_Ellipse = (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)))

# Subset data by retouch and retouch variables
df.retouch <- df |>
  filter(ARTIFACTCLASS == "RetouchedTool" & RAWMATERIAL != "BWA UPPER 1" &
           COMPLETENESS == "Complete") |>
  select(1:11,13:32,36:47,64:69)

# Read tabulated data from previous publications (i.e. Jerardino & Yates)
sbf_df <- read.csv("SBF_ToolType.csv")
sbf_un <- read.csv("SBF_ToolType_unmod.csv")
```

# Methods

Here, we examine whether hunter-gatherer technological strategies changed as they increased their focus on coastal resources at Steenbokfontein (SBF). To accomplish this, we examine 1) raw material distribution and surplus, 2) lithic tool utility and reduction intensity, and 3) retouch intensity. These data inform us about where hunter-gatherers procured, transported, maintained, and discarded their lithic technology. Technological changes between coastal and terrestrial layers imply that hunter-gatherer coastal adaptations at SBF fundamentally changed their technological strategies.

## Raw material and toolkit composition

Toolkit composition refers to the raw material distribution, surplus, and relationship between cores, flakes, and retouched tools. Raw material distribution and surplus are both directly linked to where hunter-gatherers procure, transport, and reduce their lithic tools [@andrefsky1994; @andrefsky2009; @binford; @dibble2005; @kuhn1992; @kuhn1994; @nelson1991] . Shifts in local and non-local raw materials can inform us about changes in hunter-gatherer mobility patterns [@andrefsky1994; @kelly1983] . For instance, a reduction in non-local raw material may imply reduced hunter-gatherer movement across the landscape [@kelly1992]. To evaluate this pattern, we examine changes in the proportion of raw material over time at SBF. Shifts in raw material distribution and reduced mobility will likely reflect the amount of surplus hunter-gatherers store at SBF [@surovell2009].

We use the relative size of lithics to evaluate whether raw material surplus changes between layers associated with coastal and terrestrial resource use [see @mackay2009] . Firstly, we extract the 50th and 75th percentile of lithic mass for layers associated with coastal resource use and terrestrial resource use. Then, for each raw material, we contrast these percentiles against 1) all lithic mass, 2) only core mass, and 3) maximum core length. If the average mass or length intersect the 75th percentile, then there is more raw material surplus than we would expect in that layer. If the average mass or length is at the 50th percentile, then this reflects the average expectation for the layer. If the average mass or length fall below the 50th percentile, then this reflects less raw material surplus than we would expect. As hunter-gatherers focus on coastal resources, we expect raw material surplus to increase.

We can also use lithic density, number of flakes, cores, and retouched tools to explore the composition of toolkits. Changes in the frequency of flakes, cores, and retouched tools can inform us about mobility strategies and allude to site function [@kelly1988; @kelly1992; @nelson1991] . For instance, an emphasis in retouched tools over flake production can suggest hunter-gatherer groups with higher mobility and a site that may be associated with logistical foraging patterns. Greater frequency of cores and flake production can reflect lower mobility and sites associated with residential patterns [@barton; @binford; @kelly1992]. To evaluate whether the composition of hunter-gatherer toolkits change as they focus on coastal resources, we look at 1) percent of retouched tools to lithic density, 2) retouched flakes-to-unmodified flakes, and 3) retouched flakes-to-cores.

## Lithic tool utility and reduction intensity

Surovell [-@surovell2009] and Kuhn [-@kuhn1994] explain lithic utility as the remaining portion of the lithic that can still be reduced. They define lithic utility for flakes ($f_u$) and retouched tools ($f_u$), as:

$$
f_u=l*(l-m)
$$

where *l* is the length of the tool and *m* is the *slug*, or the smallest usable length for the tool. We use these equations to estimate the utility of lithics at SBF. However, since there are increasing occurrences of *microlithic* technologies in Africa and Europe that are measured less than one centimeter [e.g. @ambrose2002; @belfer-cohen2002; @hiscock2015; @mitchell1988; @pargeter2016] , subtracting by the *slug* is likely negligible.

We adopt Lombao et al.'s [-@lombao2020; -@lombao2023] definition for reduction intensity as the amount of total volume removed from a core or tool. Previous studies have used several distinct metrics to quantify the degree of reduction intensity including volumetric reconstruction [@lombao2020; @lombao2023], scar density index (SDI) [@clarkson2013] , and a comparison between core and flake size. Volumetric reconstruction and SDI both rely on core measurements and thus, the sample size is constrained on the number of cores and not flakes. Since we measure the utility for each flake, we choose the latter approach here. That is, we average each core's maximum flake scar and subtract this by each flake's technological length. From here, we can measure changes in lithic utility, reduction intensity, and the interaction between utility and reduction intensity through SBF.

## Scraper utility and retouch intensity

Scrapers are the most abundant retouched tool at SBF and so, we explore how the utility and retouch intensity changes between layers associated with coastal and terrestrial resources. We use the same utility measurement described above to calculate scraper utility. Since all scrapers are unifacial, we adopt Eren et al.'s [-@eren2005; see also @kuhn1990] approach to quantify the retouch intensity of unifacial tools (*V*). To accomplish this, we apply their geometric equation to all scrapers at SBF:

$$
V = \frac{L D^2}{2} \left( \sin^2(a) \cot(b) - \sin(a) \cos(a) \right)
$$

where *L* is the length of the retouched edge, *D* is the retouched length, *a* is the retouched angle, and *b* is the angle where the central and dorsal planes meet. With these metrics, we can measure shifts in scraper utility, retouch intensity, and their interaction through time at SBF.

# Results

## Raw material distribution

Table 1 and @fig-RawMaterial show the distribution of artifact type by raw material. @fig-RawMaterial shows the raw material distribution by individual layer and lumped into layers associated with coastal (layers 1-3) and terrestrial diets (layers 4a and 4b). These data suggest that, as hunter-gatherer focus on coastal resources, there is a decrease in the proportion of retouched tools for all raw materials and increase in cores (@fig-RawMaterial (a)) . @fig-RawMaterial (b) shows a more nuanced raw material pattern. As silcrete cores decrease towards layer 2, there is an increase in quartzite cores. At the same time, silcrete and quartz retouched tools increase during layer 2. Additionally, table 1 shows a general decrease in silcrete materials through SBF, implying hunter-gatherers reduced the amount of silcrete brought into SBF. Together, these patterns reflect shifts in hunter-gatherer toolkits and raw material transportation when diets become centered around coastal foods.

An analysis of cortical-to-noncortical flakes (@fig-Cortical) further implies significant shifts in raw material transport. @fig-Cortical (a) shows that silcrete has the lowest cortical-to-noncortical ratios for layers associated with terrestrial diets, suggesting greater cortical silcrete. As hunter-gatherers focused on coastal resources, silcrete reflects similar ratios for quartz and quartzite. @fig-Cortical (b) shows a general decrease in quartz ratios through SBF, implying a greater proportion of non-cortical quartz flakes through time. These shifts in cortical-to-noncortical ratios confirm that hunter-gatherer modified where they procured raw material and where, on the landscape, they removed cortical pieces before transporting them into SBF.

```{r tab.cap="Count and percentage of the three main lithic categories conditioned by raw material: Cores, Flakes, and Retouched tools. Retouched tool categories contains miscelleneous retouched flakes, backed tools, and scrapers."}
#| label: tab-one


# Create summary table

df |>
  select(STRAT, RAWMATERIAL, ARTIFACTCLASS) |>
  mutate(ARTIFACTCLASS = ifelse(ARTIFACTCLASS ==
                                  "RetouchedTool", "Retouched tools", ARTIFACTCLASS),
         RAWMATERIAL = 
           fct_relevel(RAWMATERIAL,
                       "Quartz", "Quartzite", "Silcrete")) |>
  rename(Layer = STRAT,
         `Artifact class` = ARTIFACTCLASS) |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  tbl_strata(
    strata = RAWMATERIAL,
    .tbl_fun =
      ~ .x |>
        tbl_summary(by = "Artifact class", missing = "no") |> add_n()
  ) |>
  modify_header(label = "") -> tab1
```

::: landscape
`r tab1`
:::

```{r RMGGplot}

df |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  group_by(STRAT, RAWMATERIAL, ARTIFACTCLASS) |>
  summarize(Freq = n()) |>
  mutate(cs = sum(Freq),
         prop = Freq/cs) |>
  ggplot(aes(x = STRAT, y = prop, fill = ARTIFACTCLASS))+
  geom_col()+
  facet_wrap(~RAWMATERIAL)+
  labs(fill = "",
       x = "Layer",
       y = "Proportion") +
  theme_minimal()+
  scale_fill_viridis_d()+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",3),rep("Forest Green",2)))) -> RM_plot1

df |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  mutate(STRAT_mod = ifelse(STRAT %in% c("4a", "4b"), "Terrestrial", "Coastal")) |>
  group_by(STRAT_mod, RAWMATERIAL, ARTIFACTCLASS) |>
  summarize(Freq = n()) |>
  mutate(cs = sum(Freq),
         prop = Freq/cs) |>
  ggplot(aes(x = STRAT_mod, y = prop, fill = ARTIFACTCLASS))+
  geom_col()+
  facet_wrap(~RAWMATERIAL)+
  labs(fill = "",
       x = "Grouped Layers",
       y = "Proportion") +
  theme_minimal()+
  scale_fill_viridis_d()+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",1),rep("Forest Green",1)),
                       angle = 45, hjust = 1)) -> RM_plot2

```

```{r fig-RawMaterial, fig.cap="Proportion of three main lithic tool types (cores, flakes, and retouched tools) conditioned by raw material type for layers grouped by diet (A) and all layesr (B). Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}
#| label: fig-RawMaterial

ggarrange(
  RM_plot2, RM_plot1,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)
```

```{r CortexGGplot}
#| warning: false
#| message: false

# calculate the cortical to noncortical ratio based on percent of cortex and artifact surface area
iter = 100
df_cortex_boot <- tibble(STRAT = character(),
                         ratio = numeric(),
                         RAWMATERIAL = character(),
                         sample = numeric())
set.seed(1234567890)
for(i in 1:iter){
df |>
  mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                           ifelse(CORTEX == "10-40%", 0.2,
                                  ifelse(CORTEX == "1-10", 0.05,
                                         ifelse(CORTEX == "60-90%", 0.75, 0)))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  select(STRAT, RAWMATERIAL, SA, C_SA, NC_SA, cortical) |>
  slice_sample(n = nrow(df), replace = T) |>
  filter(SA < 2000) |>
  group_by(STRAT, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum,
            sample = i) |>
  select(ratio, RAWMATERIAL, sample) -> df_cortex
  
  df_cortex_boot <- rbind(df_cortex, df_cortex_boot)
}


# Compute cortical to noncortical ratio from empirical data
df_emp_cortex <- df |>
    mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                           ifelse(CORTEX == "10-40%", 0.2,
                                  ifelse(CORTEX == "1-10", 0.05,
                                         ifelse(CORTEX == "60-90%", 0.75, 0)))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  filter(SA < 2000) |>
  group_by(STRAT, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum)
  
  
  
# Plot cortical to noncortical ratios with error bars from bootstrap data
df_cortex_boot |>
  group_by(RAWMATERIAL, STRAT) |>
  summarise(lower_CI = quantile(ratio, 0.025),
            upper_CI = quantile(ratio, probs = 0.975),
            median = quantile(ratio, probs = 0.5))|>
  ggplot(aes(x = STRAT, y = median, fill = RAWMATERIAL))+
  geom_bar(data = df_emp_cortex, aes(x = STRAT, y = ratio, fill = RAWMATERIAL),
           stat = "identity", position = "dodge")+
  geom_errorbar(aes(ymin = lower_CI, ymax = upper_CI, colour = "grey"),
                position = "dodge")+
  labs(fill = "",
       x = "Layer",
       y = "Cortical-to-Noncortical Ratios") +
  theme_minimal()+
  guides(colour = "none")+
  scale_fill_viridis_d()+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",3),rep("Forest Green",2)))) -> cort_plot1
  
################## Bootstrap for modified Strats #####################
iter = 100
df_cortex_boot <- tibble(STRAT_mod = character(),
                         ratio = numeric(),
                         RAWMATERIAL = character(),
                         sample = numeric())
set.seed(234567890)
for(i in 1:iter){
df |>
  mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                           ifelse(CORTEX == "10-40%", 0.2,
                                  ifelse(CORTEX == "1-10", 0.05,
                                         ifelse(CORTEX == "60-90%", 0.75, 0)))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  select(STRAT_mod, RAWMATERIAL, SA, C_SA, NC_SA, cortical) |>
  slice_sample(n = nrow(df), replace = T) |>
  filter(SA < 2000) |>
  group_by(STRAT_mod, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum,
            sample = i) |>
  select(ratio, RAWMATERIAL, sample) -> df_cortex
  
  df_cortex_boot <- rbind(df_cortex, df_cortex_boot)
}

# Compute cortical to noncortical ratio from empirical data
df_emp_cortex <- df |>
    mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                           ifelse(CORTEX == "10-40%", 0.2,
                                  ifelse(CORTEX == "1-10", 0.05,
                                         ifelse(CORTEX == "60-90%", 0.75, 0)))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  filter(SA < 2000) |>
  group_by(STRAT_mod, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum)
  

# Plot cortical to noncortical ratios with error bars from bootstrap data
df_cortex_boot |>
  group_by(RAWMATERIAL, STRAT_mod) |>
  summarise(lower_CI = quantile(ratio, 0.025),
            upper_CI = quantile(ratio, probs = 0.975),
            median = quantile(ratio, probs = 0.5))|>
  ggplot(aes(x = STRAT_mod, y = median, fill = RAWMATERIAL))+
  geom_bar(stat = "identity", position = "dodge")+
  geom_errorbar(aes(ymin = lower_CI, ymax = upper_CI, colour = "grey"),
                position = "dodge")+
  labs(fill = "",
       x = "Grouped Layers",
       y = "Cortical-to-Noncortical Ratios") +
  theme_minimal()+
  guides(colour = "none")+
  scale_fill_viridis_d()+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",1),rep("Forest Green",1)))) -> cort_plot2

rm(df_cortex_boot)
```

```{r fig-Cortical, fig.cap="Bar plot that shows the cortical-to-noncortical ratios scaled by artifact's surface area for layers grouped by diet (A) and all layers (B). Low ratio implies greater non-cortical coverage; high ratios imply greater cortical coverage. The error bars reflect a 95% confidence interval derived from bootstrap sampling. Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}
#| label: fig-Cortical
  
ggarrange(
  cort_plot2, cort_plot1,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)
```

## Raw material surplus

@fig-ArtMass explore the relationship between raw material surplus and raw material distribution. Firstly, the 50th and 75th percentile for all artifact mass (@fig-ArtMass) is not significantly different, implying identically distributed distributions for artifact mass when between layers associated with coastal and terrestrial resource consumption. A Bayesian ANOVA shows no significant shifts within raw materials between layers, but there are significant difference between raw materials. Specifically, quartzite and secrete are consistently above the 75th percentile in both the grouped (a) and individual layers (b). This suggests there was a greater surplus of quartzite and silcrete at SBF, but this is not correlated with terrestrial or coastal diets.

@fig-CoreMass and @fig-CoreLength explore the relationship between raw material surplus, core mass, and core maximum length. Here, there is a significant difference between the mass and maximum length between layers associated with coastal and terrestrial resource use. In both figures, the terrestrial layers have, on average, smaller cores than layers associated with coastal resource use. A reduced sample size for cores increases the statistical uncertainty, but the posterior distribution for a Bayesian ANOVA still suggests no significant difference within raw material with significant shifts between raw material through SBF. Compared with the 50th and 75th percentile, quartzite and silcrete align with the 75th percentile for every layer. However, for terrestrial layers, quartz cores fall in line with the 50th percentile but fall well below this threshold when hunter-gatherers focus on coastal resources. Overall, quartzite and silcrete have, on average, larger cores while the quartz cores are significantly smaller. Moreover, quartz cores are well below average size when hunter-gatherers focus on coastal resources, which may imply reduced quartz resource surplus during these intervals.

```{r AllMassPriors}
# design model to look at the relationship between artifact mass and the 50th and 75th percentiles
# Create dataframe to fit to Bayesian models
fit_df <- df |>
    mutate(log_MASS = log(MASS))

# Cretae priors to assign to Bayesian model for two scenarios: grouped and separate layers
# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(3,0.5), class = "Intercept")+
  
  prior(normal(1,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  prior(normal(3,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+
  
  prior(gamma(2, 0.5), class = "shape")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(3,0.5), class = "Intercept")+
  
  prior(normal(2,1), class = "b", coef = "STRAT2")+
  prior(normal(2,1), class = "b", coef = "STRAT3")+
  prior(normal(1,1), class = "b", coef = "STRAT4a")+
  prior(normal(1,1), class = "b", coef = "STRAT4b")+
  
  prior(normal(3,0.5), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(0,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(1,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(1,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  
  prior(gamma(2, 0.5), class = "shape")
```

```{r AllMassBayesMods}
fit_mass_all_grouped <- brm(
  MASS ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 2325777
)

fit_mass_all_ind <- brm(
  MASS ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 2325778
)
```

```{r AllMassBayesGGplot}

df |>
  select(MASS, STRAT, RAWMATERIAL) |>
  mutate(STRAT_mod = ifelse(STRAT %in% c("1", "2", "3"),
                            "Coastal", "Terrestrial")) |>
  group_by(STRAT_mod) |>
  mutate(Quant_lower75 = quantile(log(MASS), probs = 0.75),
         Median_mid50 = quantile(log(MASS), probs = 0.5),
         dist_to_lower75 = MASS - Quant_lower75,
         dist_to_median = MASS - Median_mid50) -> df_mod

hline_aq <- df_mod |> filter(STRAT_mod == "Coastal") |>
  distinct(Median_mid50, Quant_lower75)
hline_ter <- df_mod |> filter(STRAT_mod == "Terrestrial") |>
  distinct(Median_mid50, Quant_lower75)


fit_df |>
  mutate(STRAT_mod = as.factor(STRAT_mod),
         RAWMATERIAL = as.factor(RAWMATERIAL)) |>
  ggplot(aes(x = STRAT_mod, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT_mod)))+
  geom_boxplot()+

  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.1,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "blue")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "Dark Green")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "light blue", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "light green", lty = 2)+
  
  xlab("Grouped Layers")+ylab("log-Artifact Mass")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank())+
  guides(color = "none")+
    theme(axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",1),rep("Forest Green",1))))+
  scale_fill_viridis_d() -> Art_mass_freqPlot1


fit_df |>
  ggplot(aes(x = STRAT, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.09,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
    geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "blue")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "Dark Green")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "light blue", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "light green", lty = 2)+
  
    theme_minimal()+
  theme(legend.title = element_blank())+
  xlab("Layers")+ylab("log-Artifact Mass")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank())+
  guides(color = "none")+
    theme(axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",3),rep("Forest Green",2))))+
  scale_fill_viridis_d() -> Art_mass_freqPlot2



```

```{r fig-ArtMass, fig.cap="Boxplot of log-mass for layers grouped by diet (A) and for all layers (B). The dashed lines reflect 75th percentile mass for layers associated with auqatic diets (blue) and terrestrial diets (green). The solid lines reflect the 50th percentile mass for layers associated with auqatic diets (blue) and terrestrial diets (green). Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}
#| label: fig-ArtMass


ggarrange(
  Art_mass_freqPlot1,Art_mass_freqPlot2,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)
```

```{r CoreMassPriors}
# Looking only at core Mass
fit_df <- df |>
    select(MASS, STRAT, RAWMATERIAL, ARTIFACTCLASS) |>
    filter(ARTIFACTCLASS == "Core") |>
    mutate(STRAT_mod = as.factor(ifelse(STRAT %in% c("1", "2", "3"),
                            "Coastal", "Terrestrial")),
           RAWMATERIAL = as.factor(RAWMATERIAL),
           log_MASS = log(MASS))

# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(3,0.5), class = "Intercept")+
  
  prior(normal(1,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  prior(normal(3,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+
  
  prior(gamma(2, 0.5), class = "shape")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(2,0.5), class = "Intercept")+
  
  prior(normal(2,1), class = "b", coef = "STRAT2")+
  prior(normal(2,1), class = "b", coef = "STRAT3")+
  prior(normal(1,1), class = "b", coef = "STRAT4a")+
  prior(normal(1,1), class = "b", coef = "STRAT4b")+
  
  prior(normal(3,0.5), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(0,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(1,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(1,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  
  prior(gamma(2, 0.5), class = "shape")

```

```{r CoreMassBayesMods}
fit_mass_core_grouped <- brm(
  MASS ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 23257777
)

fit_mass_core_ind <- brm(
  MASS ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 23257788
)
```

```{r CoreMassBayesGGplot}
#| warning: false
#| message: false
df |>
  filter(ARTIFACTCLASS == "Core") |>
  select(MASS, STRAT, RAWMATERIAL) |>
  mutate(STRAT_mod = ifelse(STRAT %in% c("1", "2", "3"),
                            "Coastal", "Terrestrial")) |>
  group_by(STRAT_mod) |>
  mutate(Quant_lower75 = quantile(log(MASS), probs = 0.75),
         Median_mid50 = quantile(log(MASS), probs = 0.5),
         dist_to_lower75 = MASS - Quant_lower75,
         dist_to_median = MASS - Median_mid50) -> df_mod

hline_aq <- df_mod |> filter(STRAT_mod == "Coastal") |>
  distinct(Median_mid50, Quant_lower75)
hline_ter <- df_mod |> filter(STRAT_mod == "Terrestrial") |>
  distinct(Median_mid50, Quant_lower75)



fit_df |>
  ggplot(aes(x = STRAT_mod, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT_mod)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.1,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "blue")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "Dark Green")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "light blue", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "light green", lty = 2)+
  
  
    theme_minimal()+
  theme(legend.title = element_blank())+
  xlab("Grouped Layers")+ylab("log-Core Mass")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",1),rep("Forest Green",1))))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_mass_freqPlot1


fit_df |>
  ggplot(aes(x = STRAT, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.09,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
    geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "blue")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "Dark Green")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "light blue", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "light green", lty = 2)+
  
    theme_minimal()+
  theme(legend.title = element_blank())+
  xlab("Layers")+ylab("log-Core Mass")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",3),rep("Forest Green",2))))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_mass_freqPlot2
```

```{r fig-CoreMass, fig.cap="Boxplot of log-mass for only cores in layers grouped by diet (A) and for all layers (B). The dashed lines reflect 75th percentile mass for layers associated with auqatic diets (blue) and terrestrial diets (green). The solid lines reflect the 50th percentile mass for layers associated with auqatic diets (blue) and terrestrial diets (green). Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}
#| label: fig-CoreMass


ggarrange(
  Core_mass_freqPlot1, Core_mass_freqPlot2,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)
```

```{r CoreLengthPriors}
# Looking only at core Mass
fit_df <- df |>
    select(MASS, STRAT, STRAT_mod, RAWMATERIAL, MAXLENGTH, ARTIFACTCLASS) |>
    filter(ARTIFACTCLASS == "Core") |>
    mutate(RAWMATERIAL = as.factor(RAWMATERIAL))

# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(log(18),1), class = "Intercept")+
  
  prior(normal(2,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  prior(normal(5,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(log(18),0.5), class = "Intercept")+
  
  prior(normal(3,0.5), class = "b", coef = "STRAT2")+
  prior(normal(2,0.5), class = "b", coef = "STRAT3")+
  prior(normal(1,1), class = "b", coef = "STRAT4a")+
  prior(normal(1,1), class = "b", coef = "STRAT4b")+
  
  prior(normal(3,0.5), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")
```

```{r CoreLengthBayesMods}
fit_length_core_grouped <- brm(
  MASS ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 557777
)

fit_length_core_ind <- brm(
  MASS ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 537788
)
```

```{r CoreLengthBayesGGplot}
#| warning: false
#| message: false

df |>
  filter(ARTIFACTCLASS == "Core") |>
  select(MASS, STRAT, RAWMATERIAL, MAXLENGTH) |>
  mutate(STRAT_mod = ifelse(STRAT %in% c("1", "2", "3"),
                            "Coastal", "Terrestrial")) |>
  group_by(STRAT_mod) |>
  mutate(Quant_lower75 = quantile(MAXLENGTH, probs = 0.75),
         Median_mid50 = quantile(MAXLENGTH, probs = 0.5),
         dist_to_lower75 = MASS - Quant_lower75,
         dist_to_median = MASS - Median_mid50) -> df_mod

hline_aq <- df_mod |> filter(STRAT_mod == "Coastal") |>
  distinct(Median_mid50, Quant_lower75)
hline_ter <- df_mod |> filter(STRAT_mod == "Terrestrial") |>
  distinct(Median_mid50, Quant_lower75)


fit_df |>
  ggplot(aes(x = STRAT_mod, y = MAXLENGTH, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT_mod)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.1,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "blue")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "Dark Green")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "light blue", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "light green", lty = 2)+
  
  
  xlab("Grouped Layers")+ylab("Core Length")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",1),rep("Forest Green",1))))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_length_freqPlot1


fit_df |>
  ggplot(aes(x = STRAT, y = MAXLENGTH, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.09,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
    geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "blue")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "Dark Green")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "light blue", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "light green", lty = 2)+
  
  xlab("Layers")+ylab("Core Length")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",3),rep("Forest Green",2))))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_length_freqPlot2
```

```{r fig-CoreLength, fig.cap="Boxplot of the maximum core length in layers grouped by diet (A) and for all layers (B). The dashed lines reflect 75th percentile mass for layers associated with auqatic diets (blue) and terrestrial diets (green). The solid lines reflect the 50th percentile mass for layers associated with auqatic diets (blue) and terrestrial diets (green). Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}
#| label: fig-CoreLength

ggarrange(
  Core_length_freqPlot1, Core_length_freqPlot2,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)
```

## Toolkit composition

@fig-RetouchToDensity shows the relationship between the percent of formal tools and lithic density through SBF. The expectation is that more formal tools and lower lithic density reflects hunter-gatherers that move more frequently. Fewer formal tools and a higher lithic density reflects hunter-gatherers with lower mobility strategies. @fig-RetouchToDensity implies the layers associated with coastal resource exploitation (1, 2, and 3) are associated with higher mobility and the layers associated with terrestrial resources (4a and 4b) are associated with lower mobility.

@fig-RetouchFlakeCore explores the relationship between retouched flakes, flakes, and cores. @fig-RetouchFlakeCore shows that the ratios for retouched flake-to-flake and retouched flake-to-core increase towards layers 1, 2, and 3. These data suggest that hunter-gatherers either 1) invested in more retouched tools or 2) carried more retouched tools into SBF during layers associated with coastal resources use (1, 2, and 3). In both cases, the expectation is that a greater emphasis in retouched tools reflects more mobile hunter-gatherers. These data show distinct changes in toolkits through SBF as hunter-gatherer begin to focus on coastal resources.

```{r fig-RetouchToDensity, fig.cap="Percent of retouched tools to lithic density at SBF. Higher formal tools and lower lithic density implies higher mobility; lower formal tools and higher lithic density implies lower mobility. These data suggest layers 1, 2, and 3 are asscoaited with increased mobility and layers 4a and 4b are associated with lower mobility."}
#| label: fig-RetouchToDensity


sbf_df |>
  filter(Layer != "5") |>
  mutate(Layer = ifelse(Layer %in% c("3a", "3b"), "3", Layer)) |>
  group_by(Layer) |>
  summarize(Tool_sum = sum(Count)) |>
  mutate(Lithic_Dens = c(8.8, 11.7, 16, 30.7, 18.7)) |>
  left_join(
    
    sbf_un |>
      filter(Layer != "5") |>
      mutate(Layer = ifelse(Layer %in% c("3a", "3b"), "3", Layer)) |>
      group_by(Layer) |>
      summarize(Deb_sum = sum(Count)) 
    
) |>
  mutate(Tool_Perc = (Tool_sum/Deb_sum)*100) |>
  
  ggplot(aes(x = Lithic_Dens, y = Tool_Perc, color = Layer, label = Layer))+
  geom_point(size = 2)+
  geom_text(aes(fontface = 2),hjust = 1.5, vjust = 0)+
  xlab("Lithic Density")+ylab("Formal Tool Percent")+
  theme_minimal()+
  guides(color = "none")+
  scale_color_manual(values = c("1" = "blue", "2" = "blue", "3" = "blue",
                                "4a" = "forestgreen", "4b" = "forestgreen"))+
  annotate(geom = "text", x = 28, y = 5.2, label = "Lower Mobility")+
  annotate(geom = "text", x = 12, y = 8.8, label = "Higher Mobility")
```

```{r}
sbf_un |>
  filter(Layer != "5" & Artifact.Class %in% c("Flakes", "Blades", "Bladelets",
                                              "CoreReduced", "BladeletCores",
                                              "IrregularCores", "RegularCores")) |>
  mutate(Layer = ifelse(Layer %in% c("3a", "3b"), "3", Layer),
         Artifact = ifelse(Artifact.Class %in% 
                             c("Flakes", "Blades", "Bladelets"),
                           "Flakes", "Cores")) |>
  
  group_by(Layer, Artifact) |>
  summarize(c = sum(Count)) |>
  pivot_wider(names_from = Artifact, values_from = c) |>
  inner_join(
      
    sbf_df |>
      filter(Layer != "5") |>
      mutate(Layer = ifelse(Layer %in% c("3a", "3b"), "3", Layer),
             Artifact = rep("Retouch", n())) |>
      group_by(Layer, Artifact) |>
      summarize(Retouch = sum(Count))
  ) |>

  mutate(ratio = Retouch/Cores) |>
  
  ggplot(aes(x = Layer, y = ratio, fill = Layer))+
  geom_bar(stat = "identity")+
  xlab("Layer")+ylab("Retouched Flake-to-Core Ratio")+
  theme_minimal()+
  guides(fill = "none")+
  scale_fill_manual(values = 
                      c("1" = "blue", "2" = "blue", "3" = "blue",
                        "4a" = "forestgreen", "4b" = "forestgreen")) -> Ret_Core
```

```{r}
sbf_un |>
  filter(Layer != "5" & Artifact.Class %in% c("Flakes", "Blades", "Bladelets",
                                              "CoreReduced", "BladeletCores",
                                              "IrregularCores", "RegularCores")) |>
  mutate(Layer = ifelse(Layer %in% c("3a", "3b"), "3", Layer),
         Artifact = ifelse(Artifact.Class %in% 
                             c("Flakes", "Blades", "Bladelets"),
                           "Flakes", "Cores")) |>
  
  group_by(Layer, Artifact) |>
  summarize(c = sum(Count)) |>
  pivot_wider(names_from = Artifact, values_from = c) |>
  inner_join(
      
    sbf_df |>
      filter(Layer != "5") |>
      mutate(Layer = ifelse(Layer %in% c("3a", "3b"), "3", Layer),
             Artifact = rep("Retouch", n())) |>
      group_by(Layer, Artifact) |>
      summarize(Retouch = sum(Count))
  ) |>

  mutate(ratio = Retouch/Flakes) |>
  
  ggplot(aes(x = Layer, y = ratio, fill = Layer))+
  geom_bar(stat = "identity")+
  xlab("Layer")+ylab("Retouch Flake-to-Flake Ratio")+
  theme_minimal()+
  guides(fill = "none")+
  scale_fill_manual(values = 
                      c("1" = "blue", "2" = "blue", "3" = "blue",
                        "4a" = "forestgreen", "4b" = "forestgreen")) -> Ret_Flake
```

```{r fig-RetouchFlakeCore, fig.cap="Retouched flake-to-flake (A) and retouched flake-to-core (B) ratios colored by layers associated with coastal (blue) and terrestrial resources (green). Lower values suggests less investment in retouched tools or increased movement of retouched tools out of SBF."}
#| label: fig-RetouchFlakeCore


ggarrange(
  Ret_Flake, Ret_Core,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)
```

## Flake utility and reduction intensity

@fig-FlakeUt and @fig-FlakeRed show the distribution between remaining flake utility and reduction intensity of quartz, quartzite, and silcrete. A Bayesian ANOVA for @fig-FlakeUt and @fig-FlakeRed both suggest that flake utility and reduction intensity is significantly different between raw materials but not within the raw material types across SBF's layers. Specifically, though @fig-FlakeUt (A) shows no significant difference within raw materials, (B) shows a general decreasing trend in quartzite and silcrete utility as hunter-gatherers focus on coastal resources. @fig-FlakeRed shows a similar pattern that shows a decrease in reduction intensity as hunter-gatherers focus on coastal resources. These data imply and reaffirm that hunter-gatherers modified the way they managed their local raw material (quartzite) and more distantly sourced raw material (silcrete) as they increased their coastal resource consumption.

To evaluate how hunter-gatherers managed flake utility and reduction intensity together, we calculated the ratio between utility and reduction intensity (@fig-UtRed). An ANOVA, again, shows a significant difference between raw materials but not within raw materials through SBF's sequence for grouped and individual layers. Specifically, quartzite has greater utility to reduction intensity than do quartz and silcrete materials. But overall, these results imply no significant changes in how hunter-gatherers managed flake utility and reduction intensity when they increased coastal resource use.

```{r FlakeUtilityPriors}
fit_df <- df.flakes |>
    select(STRAT, STRAT_mod, RAWMATERIAL, MAXLENGTH, Utility)

# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(log(15),1), class = "Intercept")+
  
  prior(normal(2,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  prior(normal(5,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(log(15),0.5), class = "Intercept")+
  
  prior(normal(3,0.5), class = "b", coef = "STRAT2")+
  prior(normal(2,0.5), class = "b", coef = "STRAT3")+
  prior(normal(1,1), class = "b", coef = "STRAT4a")+
  prior(normal(1,1), class = "b", coef = "STRAT4b")+
  
  prior(normal(3,0.5), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")
```

```{r FlakeUtilityBayesMods}
fit_utility_flake_grouped <- brm(
  Utility ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 557177
)

fit_utility_flake_ind <- brm(
  Utility ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 537488
)
```

```{r FlakeUtilityBayesGGplot}
fit_df |>
  ggplot(aes(x = STRAT, y = log(Utility),
                   fill = RAWMATERIAL))+
  geom_boxplot()+
    geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.15,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+

    xlab("Layers")+ylab("log-Flake Utility")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",3),rep("Forest Green",2))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> flake_utility_freqPlot1



fit_df |>
  ggplot(aes(x = STRAT_mod, y = log(Utility),
                   fill = RAWMATERIAL))+
  geom_boxplot()+
      geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.2,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+
  
    xlab("Layers")+ylab("log-Flake Utility")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",1),rep("Forest Green",1))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> flake_utility_freqPlot2
```

```{r fig-FlakeUt, fig.cap="Boxplot of log-Flake utility for layers grouped by diet (A) and all individual layers (B). There are significant differences between raw material but not within raw material. Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}
#| label: fig-FlakeUt


ggarrange(
  flake_utility_freqPlot2, flake_utility_freqPlot1,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)
```

```{r FlakeRedPriors}
fit_df <- df.flakes |>
  select(MASS, STRAT, RAWMATERIAL, ARTIFACTCLASS,
         MAXLENGTH, MAXWIDTH, Reduction) |>
    mutate(STRAT_mod = ifelse(STRAT %in% c("4a", "4b"), "Terrestrial", "Coastal"),
           CE = MAXWIDTH+(MAXLENGTH*2)/(MASS^(1/3)))

# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(log(15),1), class = "Intercept")+
  
  prior(normal(2,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  prior(normal(5,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(log(15),0.5), class = "Intercept")+
  
  prior(normal(3,0.5), class = "b", coef = "STRAT2")+
  prior(normal(2,0.5), class = "b", coef = "STRAT3")+
  prior(normal(1,1), class = "b", coef = "STRAT4a")+
  prior(normal(1,1), class = "b", coef = "STRAT4b")+
  
  prior(normal(3,0.5), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")
```

```{r FlakeRedBayesMods}
fit_red_flake_grouped <- brm(
  Reduction ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 557171
)

fit_red_flake_ind <- brm(
  Reduction ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 537484
)
```

```{r FlakeRedBayesGGplot}
fit_df |>
  ggplot(aes(x = STRAT, y = log(Reduction),
                   fill = RAWMATERIAL))+
  geom_boxplot()+
    geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.15,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+

    xlab("Layers")+ylab("log-Reduction Intensity")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",3),rep("Forest Green",2))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> flake_red_freqPlot1



fit_df |>
  ggplot(aes(x = STRAT_mod, y = log(Reduction),
                   fill = RAWMATERIAL))+
  geom_boxplot()+
      geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.2,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+
  
    xlab("Layers")+ylab("log-Reduction Intensity")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",1),rep("Forest Green",1))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> flake_red_freqPlot2
  
```

```{r fig-FlakeRed, fig.cap="Boxplot of log-Flake utility for layers grouped by diet (A) and all individual layers (B). There are significant differences between raw material but not within raw material. Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}
#| label: fig-FlakeRed


ggarrange(
  flake_red_freqPlot2, flake_red_freqPlot1,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)
```

```{r flakeUtRedPriors}
fit_df <- df.flakes |>
  select(MASS, STRAT, RAWMATERIAL, ARTIFACTCLASS,
         MAXLENGTH, MAXWIDTH, Reduction, Utility) |>
    mutate(Ut_Red = Utility/Reduction,
           STRAT_mod = ifelse(STRAT %in% c("4a", "4b"), "Terrestrial", "Coastal"))

# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(log(3),1), class = "Intercept")+
  
  prior(normal(2,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  prior(normal(5,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(log(3),0.5), class = "Intercept")+
  
  prior(normal(3,0.5), class = "b", coef = "STRAT2")+
  prior(normal(2,0.5), class = "b", coef = "STRAT3")+
  prior(normal(1,1), class = "b", coef = "STRAT4a")+
  prior(normal(1,1), class = "b", coef = "STRAT4b")+
  
  prior(normal(3,0.5), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")
```

```{r flakeUtRedBayesMods}
fit_UtRed_flake_grouped <- brm(
  Ut_Red ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 5571711
)

fit_UtRed_flake_ind <- brm(
  Ut_Red ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 5374844
)
```

```{r flakeUtRedBayesGGplot}
fit_df |>
  ggplot(aes(x = STRAT, y = log(Ut_Red),
                   fill = RAWMATERIAL))+
  geom_boxplot()+
    geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.15,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+

    xlab("Layers")+ylab("log-Utility to Reduction intensity")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",3),rep("Forest Green",2))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> ut_red_freqPlot1



fit_df |>
  ggplot(aes(x = STRAT_mod, y = log(Ut_Red),
                   fill = RAWMATERIAL))+
  geom_boxplot()+
      geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.2,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+
  
    xlab("Layers")+ylab("log-Utility to Reduction Intensity")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",1),rep("Forest Green",1))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> ut_red_freqPlot2
```

```{r fig-UtRed, fig.cap="Boxplot of log-Flake utility for layers grouped by diet (A) and all individual layers (B). There are significant differences between raw material but not within raw material. Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}
#| label: fig-UtRed


ggarrange(
  ut_red_freqPlot1, ut_red_freqPlot2,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)
```

## Scraper utility and retouch intensity

@fig-ScrapRed and @fig-ScrapRed2 both suggests there is a relationship between scraper retouch and whether hunter-gatherers are focused on coastal resources. @fig-ScrapRed and a Bayesian ANOVA show no significant difference between raw materials. Since both raw materials are fine-grained and are not statistically different, @fig-ScrapRed2 contains both quartz and silcrete. A Bayesian ANOVA for @fig-ScrapRed2 suggests that there is a significant difference between layers associated with coastal (1-3) and terrestrial resources (4a and 4b). Specifically, scrapers show lower reduction intensity during periods associated with coastal resource use. These data imply that, as hunter-gatherers focused on coastal resources, there were significant shifts in how scrapers were reduced at SBF.

@fig-ScrapUt shows the relationship between scraper utility and coastal resource use, including both quartz and silcrete. A Bayesian ANOVA suggests that there is a significant difference between layers associated with coastal (1-3) and terrestrial (4a and 4b) resource use. As hunter-gatherer focus on coastal resources, there is a significant shift in scrapers that have a lower utility. In other words, the scrapers have lower surface area during layers associated with coastal resources.

Lastly, @fig-ScrapReUt illustrates the relationship between scraper utility and retouch intensity through SBF. Again, we see lower values during periods associated with coastal resource use, which suggests a greater amount of retouch for smaller scrapers. However, a Bayesian ANOVA suggests that there is no significant difference between layers grouped into coastal and terrestrial resource use (@fig-ScrapReUt (A)). Layer 1 appears to be the only significantly different relationship between retouch intensity and flake utility. Ultimately, these results suggest that, while retouch intensity and utility significantly change through SBF, there is no noticeable change in how hunter-gatherers managed these metrics until layer 1.

```{r scraperRetouchIntensity}
# Define a database for scraper retouch
df.scrap <- df.retouch |>
  filter(RETOUCHEDPIECETYPOLOGY == "SideScraper" | 
           RETOUCHEDPIECETYPOLOGY == "EndScraper" |
           RETOUCHEDPIECETYPOLOGY == "Side-EndScraper") |>
  select(1:11,14:21, 33:43, 44:49) |>
  select("SCRAPERRETOUCHHEIGHT1", "SCRAPERRETOUCHHEIGHT2", "SCRAPERRETOUCHHEIGHT3",
         "SCRAPERRETOUCHANGLE1", "SCRAPERRETOUCHANGLE2", "SCRAPERRETOUCHANGLE3",
         "SCRAPERDORSALANGLE1", "SCRAPERDORSALANGLE2", "SCRAPERDORSALANGLE3",
         "SCRAPERRETOUCHLENGTH",
         "SCRAPERMAXTHICKNESS",
         "MAXLENGTH", "MAXWIDTH",
         
         "RAWMATERIAL", "STRAT", "MASS") |>
  na.omit() |>
  mutate(RET_INT = round(((SCRAPERRETOUCHHEIGHT1+
                            SCRAPERRETOUCHHEIGHT2+
                            SCRAPERRETOUCHHEIGHT3)/SCRAPERMAXTHICKNESS)*
                           SCRAPERRETOUCHLENGTH,2),
         SA = MAXLENGTH*MAXWIDTH)


# Preprocess data to enter into custom function to calculate scraper reduction
scrap.red <- df.scrap |>
  na.omit() |>
  mutate(D = (SCRAPERRETOUCHHEIGHT1+SCRAPERRETOUCHHEIGHT2+SCRAPERRETOUCHHEIGHT3)/3,
         a = (SCRAPERRETOUCHANGLE1+SCRAPERRETOUCHANGLE2+SCRAPERRETOUCHANGLE3)/3,
         b = (SCRAPERDORSALANGLE1+SCRAPERDORSALANGLE2+SCRAPERDORSALANGLE3)/3) |>
  rename(L = SCRAPERRETOUCHLENGTH)

scrap.red <- scraper_red(scrap.red$L, scrap.red$D, scrap.red$a, scrap.red$b)/1000

scrap.red <- scrap.red |>
  mutate(RE = as.vector(scrap.red$Reduction),
         STRAT = df.scrap$STRAT,
         UTILITY = df.scrap$MAXWIDTH*df.scrap$MAXLENGTH,
         
         RAWMATERIAL = df.scrap$RAWMATERIAL,
         
         RE_Ut = UTILITY/Reduction,
         
         MASS = df.scrap$MASS)
```

```{r scraperRedPriors}
fit_df <- scrap.red |>
  mutate(STRAT_mod = ifelse(STRAT %in% c("4a", "4b"), "Terrestrial", "Coastal"))

# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(log(2),0.5), class = "Intercept")+
  
  prior(normal(1,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(1,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(log(2),0.5), class = "Intercept")+
  
  prior(normal(1,0.5), class = "b", coef = "STRAT2")+
  prior(normal(0,0.5), class = "b", coef = "STRAT3")+
  prior(normal(0,1), class = "b", coef = "STRAT4a")+
  prior(normal(0,1), class = "b", coef = "STRAT4b")+
  
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(0,1), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(0,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(0,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(0,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")



# Priors for individual model without raw material
Prior_Ind <- prior(normal(log(2),0.5), class = "Intercept")+
  
  prior(normal(1,0.5), class = "b", coef = "STRAT2")+
  prior(normal(0,0.5), class = "b", coef = "STRAT3")+
  prior(normal(0,1), class = "b", coef = "STRAT4a")+
  prior(normal(0,1), class = "b", coef = "STRAT4b")

Prior_Grouped <- prior(normal(log(2),0.5), class = "Intercept")+
  prior(normal(1,0.5), class = "b")
```

```{r scraperRedBayesMods}
fit_red_scrap_grouped <- brm(
  RE ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 5971711
)

fit_red_scrap_ind <- brm(
  RE ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 5874844
)

# Individual model without raw material
fit_red_scrap1 <- brm(
  RE ~ STRAT,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Prior_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 58999
)

# Grouped model without raw material
fit_red_scrap2 <- brm(
  RE ~ STRAT_mod,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Prior_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 58998
)
```

```{r scraperRedBayesGGplot}
fit_df |>
  ggplot(aes(x = STRAT, y = log(RE),
                   fill = RAWMATERIAL))+
  geom_boxplot()+
    geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.15,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+

    xlab("Layers")+ylab("log-Scraper Retouch Intensity")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",3),rep("Forest Green",2))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> RE_Scrap_freqPlot1



fit_df |>
  ggplot(aes(x = STRAT_mod, y = log(RE),
                   fill = RAWMATERIAL))+
  geom_boxplot()+
      geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.2,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+
  
    xlab("Layers")+ylab("log-Scraper Retouch Intensity")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",1),rep("Forest Green",1))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> RE_Scrap_freqPlot2
```

```{r fig-ScrapRed, fig.cap="Boxplot of log-scraper retouch intensity for layers grouped by diet (A) and all individual layers (B), conditioned by raw materials. There are significant differences between layers asscoiated with coastal and terrestrial diets, but no significant differences between quartz and silcrete. Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}
#| label: fig-ScrapRed

ggarrange(
  RE_Scrap_freqPlot2, RE_Scrap_freqPlot1,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)
```

```{r scraperRedBayesGGPlot2}
fit_df |>
  ggplot(aes(x = STRAT, y = log(RE)))+
  geom_boxplot()+
      geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.2,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+
  
    xlab("Layers")+ylab("log-Scraper Retouch Intensity")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",3),rep("Forest Green",2))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> RE_Scrap_freqPlot3



fit_df |>
  ggplot(aes(x = STRAT_mod, y = log(RE)))+
  geom_boxplot()+
      geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.2,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+
  
    xlab("Layers")+ylab("log-Scraper Retouch Intensity")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",1),rep("Forest Green",1))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> RE_Scrap_freqPlot4
```

```{r fig-ScrapRed2, fig.cap="Boxplot of log-scraper retouch intensity for layers grouped by diet (A) and all individual layers (B), which include quartz and silcrete materials. There are significant differences between layers asscoiated with coastal and terrestrial diets. Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}
#| label: fig-ScrapRed2

ggarrange(
  RE_Scrap_freqPlot4, RE_Scrap_freqPlot3,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)
```

```{r scraperUtPriors}
fit_df <- scrap.red |>
  mutate(STRAT_mod = ifelse(STRAT %in% c("4a", "4b"), "Terrestrial", "Coastal"))


# Priors for individual model without raw material
Prior_Ind <- prior(normal(log(190),0.5), class = "Intercept")+
  
  prior(normal(1,0.5), class = "b", coef = "STRAT2")+
  prior(normal(2,0.5), class = "b", coef = "STRAT3")+
  prior(normal(6,1.5), class = "b", coef = "STRAT4a")+
  prior(normal(6,1.5), class = "b", coef = "STRAT4b")

Prior_Grouped <- prior(normal(log(125),0.5), class = "Intercept")+
  prior(normal(6,1.5), class = "b")
```

```{r scraperUtBayesMods}
# Individual model without raw material
fit_ut_scrap_ind <- brm(
  UTILITY ~ STRAT,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Prior_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 510999
)

# Grouped model without raw material
fit_ut_scrap_grouped <- brm(
  UTILITY ~ STRAT_mod,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Prior_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 5948991
)
```

```{r scraperUtBayesGGplot}
fit_df |>
  ggplot(aes(x = STRAT, y = log(UTILITY)))+
  geom_boxplot()+
    geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.15,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+

    xlab("Layers")+ylab("log-Scraper Utility")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",3),rep("Forest Green",2))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> Ut_Scrap_freqPlot1



fit_df |>
  ggplot(aes(x = STRAT_mod, y = log(UTILITY)))+
  geom_boxplot()+
      geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.2,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+
  
    xlab("Layers")+ylab("log-Scraper Utility")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",1),rep("Forest Green",1))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> Ut_Scrap_freqPlot2
```

```{r fig-ScrapUt, fig.cap="Boxplot of log-scraper utility for layers grouped by diet (A) and all individual layers (B), which include quartz and silcrete materials. There are significant differences between layers asscoiated with coastal and terrestrial diets. Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}
#| label: fig-ScrapUt

ggarrange(
  Ut_Scrap_freqPlot2, Ut_Scrap_freqPlot1,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)
```

```{r scraperRetUtPriors}
fit_df <- scrap.red |>
  mutate(STRAT_mod = ifelse(STRAT %in% c("4a", "4b"), "Terrestrial", "Coastal"))


# Priors for individual model without raw material
Prior_Ind <- prior(normal(log(125),0.5), class = "Intercept")+
  
  prior(normal(2,1), class = "b", coef = "STRAT2")+
  prior(normal(2,1), class = "b", coef = "STRAT3")+
  prior(normal(7,1.5), class = "b", coef = "STRAT4a")+
  prior(normal(7,1.5), class = "b", coef = "STRAT4b")

Prior_Grouped <- prior(normal(log(125),0.5), class = "Intercept")+
  prior(normal(7,1.5), class = "b")
```

```{r scrapeRetUtBayesMods}
# Individual model without raw material
fit_ReUt_scrap_ind <- brm(
  RE_Ut ~ STRAT,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Prior_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 5159991
)

# Grouped model without raw material
fit_ReUt_scrap_grouped <- brm(
  RE_Ut ~ STRAT_mod,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Prior_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 5942913
)
```

```{r scraperRetUtBayesGGplot}
fit_df |>
  ggplot(aes(x = STRAT, y = log(UTILITY)))+
  geom_boxplot()+
    geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.15,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+

    xlab("Layers")+ylab("log-Scraper Retouch-to-Utility")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",3),rep("Forest Green",2))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> ReUt_Scrap_freqPlot1



fit_df |>
  ggplot(aes(x = STRAT_mod, y = log(UTILITY)))+
  geom_boxplot()+
      geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.2,
                                             jitter.height = 0,
                                             dodge.width = 0.75),
             alpha = 0.4)+
  
    xlab("Layers")+ylab("log-Scraper Retouch-to-Utility")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("Blue",1),rep("Forest Green",1))))+
  guides(color = "none")+
  scale_fill_viridis_d()-> ReUt_Scrap_freqPlot2
```

```{r fig-ScrapReUt, fig.cap="Boxplot of log-scraper reduction intensity-to-utility for layers grouped by diet (A) and all individual layers (B), which include quartz and silcrete materials. There are significant differences between layers asscoiated with coastal and terrestrial diets. Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}
#| label: fig-ScrapReUt

ggarrange(
  ReUt_Scrap_freqPlot2, ReUt_Scrap_freqPlot1,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)
```

\newpage

# Supplemental Tables

```{r backupPlot}
#| include: false
#| echo: false

emmeans_res <- emmeans(fit_red_flake_grouped, ~ STRAT_mod*RAWMATERIAL)

# Pairwise comparisons with Bayesian credible intervals
pairs1 <- pairs(emmeans_res)

# Below I formatted the levels to match all other tests
as_tibble(pairs1) |>
  group_by(contrast) |>
  mutate(contrast = 
           paste(rev(strsplit(contrast, " - ")[[1]]), collapse = " - "), # reformat strings
         # reverse estimate because I had to reverse the above comparisons
         lwr = lower.HPD*(-1),
         upr = upper.HPD*(-1),
         diff = estimate*(-1)) |> 
  mutate(contrast = factor(contrast),
         contrast_num = as.numeric(contrast)) -> pairs_plot

factors <- levels(pairs_plot$contrast) # assign levels for additional analyses

  
pairs_plot |>
  ggplot(aes(x = diff, y = contrast, xmin = lwr, xmax = upr)) +
  geom_rect(aes(ymin = contrast_num-0.3, ymax = contrast_num+0.3),
                alpha = 0.7, fill = "#b3b1ec")+
  geom_point(size = 2)+
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(title = "", y = "Pairwise Comparisons", x = "Estimate")
```

## Raw material surplus

```{r tab-AllMassGroup, tab.cap="Bayesian ANOVA of the mass for all artifacts for layers grouped by diet. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_mass_all_grouped, ~ STRAT_mod*RAWMATERIAL)

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )


pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

```{r tab-AllMassInd, tab.cap="Bayesian ANOVA of the mass for all artifacts for individual layers. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_mass_all_ind, ~ STRAT*RAWMATERIAL)

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )


pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

## 

```{r tab-CoreMassGroup, tab.cap="Bayesian ANOVA of core mass for layers grouped by diet. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_mass_core_grouped, ~ STRAT_mod*RAWMATERIAL)

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )


pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

```{r tab-CoreMassInd, tab.cap="Bayesian ANOVA of core mass for individual layers. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_mass_core_ind, ~ STRAT*RAWMATERIAL)

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )


pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

## 

```{r tab-CoreLengthGroup, tab.cap="Bayesian ANOVA of maximum core length for layers grouped by diet. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_length_core_grouped, ~ STRAT_mod*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

```{r tab-CoreLengthInd, tab.cap="Bayesian ANOVA of maximum core length for individual layers. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_length_core_ind, ~ STRAT*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

## Flake utility and reduction intensity

### Utility

```{r tab-FlakeUtilityGroup, tab.cap="Bayesian ANOVA of flake utility for layers grouped by diet. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_utility_flake_grouped, ~ STRAT_mod*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

```{r tab-FlakeUtilityInd, tab.cap="Bayesian ANOVA of flake utility for individual layers. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_utility_flake_ind, ~ STRAT*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

### Reduction intensity

```{r tab-FlakeRedGroup, tab.cap="Bayesian ANOVA of reduction intensity for layers grouped by diet. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_red_flake_grouped, ~ STRAT_mod*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

```{r tab-FlakeRedInd, tab.cap="Bayesian ANOVA of reduction intensity for individual layers. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_red_flake_ind, ~ STRAT*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

### Utility-to-reduction intensity

```{r tab-FlakeUtRedGroup, tab.cap="Bayesian ANOVA of utility-to-reduction intensity for layers grouped by diet. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_UtRed_flake_grouped, ~ STRAT_mod*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

```{r tab-FlakeUtRedInd, tab.cap="Bayesian ANOVA of utility-to-reduction intensity for individual. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_UtRed_flake_ind, ~ STRAT*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

## Scraper utility and retouch intensity

### Retouch intensity by raw material

```{r tab-scraperRetGroup, tab.cap="Bayesian ANOVA of scraper retouch intensity for layers grouped by diet for all raw materials. The red rows show significantly different distributions within a 95% credible interval (CI)."}
# posterior distributions
emmeans_res <- emmeans(fit_red_scrap2, ~ STRAT_mod)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

```{r tab-scraperRetInd, tab.cap="Bayesian ANOVA of scraper retouch intensity for individual layers for all aw materials. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_red_scrap_ind, ~ STRAT*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

### Retouch intensity all raw materials

```{r tab-scraperRetGroup2, tab.cap="Bayesian ANOVA of scraper retouch intensity for layers grouped by diet not conditioned by raw material. The red rows show significantly different distributions within a 95% credible interval (CI)."}
# Posterior distributions with all raw materials
emmeans_res <- emmeans(fit_red_scrap2, ~ STRAT_mod)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

```{r tab-scraperRetInd2, tab.cap="Bayesian ANOVA of scraper retouch intensity for inividual layers not conditioned by raw material. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_red_scrap1, ~ STRAT)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

### Utility

```{r tab-scraperRetUtGroup1, tab.cap="Bayesian ANOVA of scraper utility for layers grouped by diet and not conditioned by raw material. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_ut_scrap_grouped, ~ STRAT_mod)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

```{r tab-scraperRetUtInd1, tab.cap="Bayesian ANOVA of scraper utility for individual layers grouped by diet and not conditioned by raw material. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_ut_scrap_ind, ~ STRAT)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

### Retouch intensity-to-utility

```{r tab-scraperRetUtGroup2, tab.cap="Bayesian ANOVA of scraper retouch intensit-to-utility for layers grouped by diet and not conditioned by raw material. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_ReUt_scrap_grouped, ~ STRAT_mod)

# Pairwise comparisons with Bayesian credible intervals
pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```

```{r tab-scraperRetUtInd2, tab.cap="Bayesian ANOVA of scraper retouch intensit-to-utility for individual layers and not conditioned by raw material. The red rows show significantly different distributions within a 95% credible interval (CI)."}
emmeans_res <- emmeans(fit_ReUt_scrap_ind, ~ STRAT)

# Pairwise comparisons with Bayesian credible intervals
pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

pairs1 |>
  kable(booktabs = T) |>
  kable_styling() |>
  row_spec(color_me, color = "black",
           background = "red")
```
